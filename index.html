let capturedImageBase64 = null;
let selectedPrompt = null;
let selectedStyleLabel = null; 
let cameraStarted = false;
let selectedGender = 'Male';
let selectedComplexionCode = null;
let imageCaptured = false;
let aiGenerationComplete = false; 

const NEGATIVE_PROMPT = "extra fingers, blurry, low resolution, bad hands, deformed face, mask artifact, bad blending, unnatural hair hair color, ugly, tiling, duplicate, abstract, cartoon, distorted pupils, bad lighting, cropped, grainy, noise, poor lighting, poor composition, low quality, changed clothing, changed background, new outfit, new background, different lighting";

const ALL_MALE_STYLES = [
    { code: 'default', src: "styles/male/style1.png", label: "Tousled Short Crop", prompt: "A short haircut with a tousled and textured top, dark brown color, sharp side profile." },
    { code: 'default', src: "styles/male/style2.png", label: "Wavy Clean Fade", prompt: "A clean fade with a slightly messy wavy top, medium brown color, defined jawline framing" },
    { code: 'default', src: "styles/male/style3.png", label: "Classic Side-Part", prompt: "A classic side-part with a smooth combed finish, ash black color, crisp temple blend." },
    { code: 'default', src: "styles/male/style4.png", label: "Curly Short Crop", prompt: "A short curly crop with tight texture, deep black color, taper fade around the ears." },
    { code: 'default', src: "styles/male/style5.png", label: "Layered Shag Cut", prompt: "A medium-length shag with layered volume, chestnut brown color, soft silhouette." },
    { code: 'default', src: "styles/male/style6.png", label: "Textured Buzz", prompt: "A buzz cut with subtle texture on top, dark blonde color, strong and structured profile." },
    { code: 'default', src: "styles/male/style7.png", label: "Modern Quiff", prompt: "A modern quiff with height and soft edges, dark brown color, low fade on the sides." },
    { code: 'default', src: "styles/male/style8.png", label: "Textured Fringe", prompt: "A textured fringe with choppy layers, sandy brown color, relaxed and youthful feel." },
    { code: 'default', src: "styles/male/style9.png", label: "Wavy Slick-Back", prompt: "A slick-back style with slight wave, espresso black color, clean undercut detail." },
    { code: 'default', src: "styles/male/style10.png", label: "Caesar Crop", prompt: "A cropped Caesar cut with short bangs, warm brown color, sharp and tidy shape." },
    { code: 'default', src: "styles/male/style11.png", label: "Swept-Back Medium", prompt: "A medium-length swept-back style with natural flow, golden brown color, tapered sides." },
    { code: 'default', src: "styles/male/style12.png", label: "Curly Undercut", prompt: "A curly undercut with defined top volume, jet black color, bold contrast in lengths." },
    { code: 'default', src: "styles/male/style13.png", label: "Messy Medium Crop", prompt: "A messy medium crop with subtle waves, chocolate brown color, soft shadow fade." },
    { code: 'default', src: "styles/male/style14.png", label: "Spiky Short Fade", prompt: "A spiky short top with controlled texture, dark brown color, sharp high fade." },
    { code: 'default', src: "styles/male/style15.png", label: "Forward Brush Cut", prompt: "A long top with brushed-forward texture, deep mahogany color, tight sides for structure." },
    { code: 'default', src: "styles/male/style16.png", label: "Textured Buzz Fade", prompt: "A low-maintenance textured buzz with slight stubble blend, dark ash brown color." },
    { code: 'default', src: "styles/male/style17.png", label: "Smooth Pompadour", prompt: "A voluminous pompadour with smooth finish, black-brown color, clean and polished sides." },
    { code: 'default', src: "styles/male/style18.png", label: "Surfer Waves", prompt: "A relaxed surfer-style wave with medium length, sandy blonde color, natural movement." },
    { code: 'default', src: "styles/male/style19.png", label: "High-Contrast Crop", prompt: "A detailed crop with high contrast fade, smoky black color, strong forehead line." },
    { code: 'default', src: "styles/male/style20.png", label: "Layered Side Sweep", prompt: "A medium layered cut with side sweep, warm auburn brown color, gentle taper." },
    { code: 'default', src: "styles/male/style21.png", label: "Modern Mullet", prompt: "A modern mullet with short front and layered back flow, dark charcoal color, bold silhouette." },
    { code: 'ds', src: "styles/male/ds/1.png", label: "Low Fade Coils", prompt: "A low fade with short tight coils on top, natural black color, clean hairline finish." },
    { code: 'ds', src: "styles/male/ds/2.png", label: "Classic Afro", prompt: "A classic afro with rounded shape, dense texture, bold and balanced silhouette." },
    { code: 'ds', src: "styles/male/ds/3.png", label: "Short Twists Fade", prompt: "Short twists with a taper fade, deep black color, neat and modern profile." },
    { code: 'ds', src: "styles/male/ds/4.png", label: "Wave Crop", prompt: "A cropped cut with waves brushed forward, jet black color, sharp temple lines." },
    { code: 'ds', src: "styles/male/ds/5.png", label: "High-Top Fade", prompt: "A high-top fade with structured volume, natural black color, strong vertical shape." },
    { code: 'ds', src: "styles/male/ds/6.png", label: "Clean Buzz Cut", prompt: "A buzz cut with precise edge-up, dark black color, minimal and clean look." },
    { code: 'ds', src: "styles/male/ds/7.png", label: "Pulled-Back Locs", prompt: "Medium-length locs pulled back, natural black color, relaxed and confident style." },
    { code: 'ds', src: "styles/male/ds/8.png", label: "Sponge Curl Fade", prompt: "A short curly fade with sponge-textured top, dense coils, smooth side blend." },
    { code: 'ds', src: "styles/male/ds/9.png", label: "Straight Cornrows", prompt: "Cornrow braids with straight-back pattern, natural black color, clean scalp lines." },
    { code: 'ds', src: "styles/male/ds/10.png", label: "Tapered Afro", prompt: "A tapered afro with controlled volume, matte black color, soft rounded outline." },
    { code: 'ds', src: "styles/male/ds/11.png", label: "Curly Frohawk", prompt: "A short frohawk with faded sides, tight curls, bold center emphasis." },
    { code: 'ds', src: "styles/male/ds/12.png", label: "Finger Coils", prompt: "Defined finger coils with low taper, black color, glossy textured finish." },
    { code: 'ds', src: "styles/male/ds/13.png", label: "Bald Fade Curls", prompt: "A bald fade with very short, naturally lying curls on top, dark black tone, crisp contrast." },
    { code: 'ds', src: "styles/male/ds/14.png", label: "Freeform Locs", prompt: "Freeform locs with medium length, natural texture, organic silhouette." },
    { code: 'ds', src: "styles/male/ds/15.png", label: "Burst Fade Curls", prompt: "A burst fade with curly top, black color, rounded side profile." },
    { code: 'ds', src: "styles/male/ds/16.png", label: "Short Box Braids", prompt: "Short box braids with neat parting, dark black color, uniform structure." },
    { code: 'ds', src: "styles/male/ds/17.png", label: "Flat Brush Cut", prompt: "A flat brush cut with subtle wave pattern, jet black color, sharp geometry." },
    { code: 'ds', src: "styles/male/ds/18.png", label: "Short Afro Crop", prompt: "A short afro crop with even density, natural black tone." }
];

function showError(message, duration = 5000) {
    errorContainer.textContent = message;
    errorContainer.classList.add('visible');
    statusMessage.textContent = 'Error occurred. Please try again.';
    
    if (duration > 0) {
        setTimeout(() => {
            errorContainer.classList.remove('visible');
        }, duration);
    }
}

function shuffle(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
}

function createStyleElement(style) {
    const div = document.createElement('div');
    div.className = 'style-option';
    div.dataset.prompt = style.prompt;
    div.dataset.complexionCode = style.code;
    
    const img = document.createElement('img');
    img.className = 'style-thumbnail';
    img.src = style.src;
    img.alt = style.label;
    
    const p = document.createElement('p');
    p.textContent = style.label;

    div.appendChild(img);
    div.appendChild(p);
    
    div.addEventListener('click', () => handleStyleSelect(div));
    return div;
}

function renderStyles(container, stylesArray) {
    container.innerHTML = '';
    stylesArray.forEach(style => {
        container.appendChild(createStyleElement(style));
    });
    setupScrollListeners(container);
}

function updateMaleStyleGallery(filterCode = null) {
    let filteredStyles;
    
    if (filterCode) {
        filteredStyles = ALL_MALE_STYLES.filter(style => style.code === filterCode);
    } else {
        filteredStyles = ALL_MALE_STYLES;
    }

    const shuffledStyles = shuffle([...filteredStyles]);
    renderStyles(maleStyleOptionsGroup, shuffledStyles);
    
    selectedPrompt = null;
    selectedStyleLabel = null;
    updateButtonVisibility();
    maleStyleOptionsGroup.scrollLeft = 0;
}

function updateButtonVisibility() {
    cameraCaptureBtn.style.display = 'none';
    redoSelfieBtn.style.display = 'none';
    generateLookBtn.style.display = 'none';
    bookAppointmentBtn.style.display = 'none'; 
    spinner.style.display = 'none';

    if (spinner.classList.contains('active')) {
        spinner.style.display = 'block';
    } else if (aiGenerationComplete) {
        redoSelfieBtn.style.display = 'flex'; 
        bookAppointmentBtn.style.display = 'flex'; 
        statusMessage.textContent = `Success! Your new look is ready. Book an appointment or click ðŸ”„ to redo.`;
    } else if (imageCaptured) {
        redoSelfieBtn.style.display = 'flex'; 
        if (selectedPrompt) {
            generateLookBtn.style.display = 'flex'; 
            generateLookBtn.disabled = false;
            const complexionStatus = selectedComplexionCode ? `(Complexion Filter Active)` : '';
            statusMessage.textContent = `Style selected: ${selectedStyleLabel}. Click âœ¨ to generate ${complexionStatus}.`;
        } else {
            statusMessage.textContent = "Image captured. Select a hairstyle to unlock the 'Generate' button.";
        }
    } else {
        cameraCaptureBtn.style.display = 'flex';
        cameraCaptureBtn.disabled = !cameraStarted; 
        if (cameraStarted) {
            statusMessage.textContent = "Adjust your face in the box, then click ðŸ“¸ to capture.";
        } else {
            statusMessage.textContent = "Tap the silhouette above to take a selfie"; 
        }
    }
}

function findClosestToCenter(scrollContainer, styleOptions) {
    const containerCenter = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2);
    let closestOption = null;
    let minDifference = Infinity;

    styleOptions.forEach(option => {
        const optionCenter = option.offsetLeft + (option.offsetWidth / 2);
        const difference = Math.abs(optionCenter - containerCenter);

        if (difference < minDifference) {
            minDifference = difference;
            closestOption = option;
        }
    });

    return closestOption;
}

function updateStyleSelectionOnScroll(scrollContainer, allOptions) {
    if (scrollContainer.style.display === 'none') return;
    
    const closestOption = findClosestToCenter(scrollContainer, allOptions);

    if (closestOption) {
        if (!closestOption.classList.contains('selected')) {
            allOptions.forEach(o => o.classList.remove('selected'));
            closestOption.classList.add('selected');
        }
        
        if (selectedPrompt !== closestOption.dataset.prompt) {
            selectedPrompt = closestOption.dataset.prompt;
            selectedStyleLabel = closestOption.querySelector('p').textContent || closestOption.dataset.prompt; 
            updateButtonVisibility(); 
        }
    }
}

const setupScrollListeners = (groupWrapper) => {
    const allOptions = groupWrapper.querySelectorAll('.style-option');
    if (allOptions.length === 0) return;

    const scrollHandler = () => {
        updateStyleSelectionOnScroll(groupWrapper, allOptions);
    };

    const oldHandler = groupWrapper._scrollHandler;
    if (oldHandler) {
        groupWrapper.removeEventListener('scroll', oldHandler);
    }

    groupWrapper.addEventListener('scroll', scrollHandler);
    groupWrapper._scrollHandler = scrollHandler;
    scrollHandler(); 
};

function handleGenderSelect(gender) {
    selectedComplexionCode = null;
    complexionGroup.querySelectorAll('.complexion-tile').forEach(t => t.classList.remove('selected'));
    
    selectedGender = gender;
    
    maleGenderBtn.classList.remove('selected');
    femaleGenderBtn.classList.remove('selected');
    
    if (gender === 'Male') {
        maleGenderBtn.classList.add('selected');
        maleStyleOptionsGroup.style.display = 'flex';
        femaleStyleOptionsGroup.style.display = 'none';
        filtersAccordion.style.display = 'block';
        updateMaleStyleGallery(null); 
    } else if (gender === 'Female') {
        femaleGenderBtn.classList.add('selected');
        maleStyleOptionsGroup.style.display = 'none';
        femaleStyleOptionsGroup.style.display = 'flex';
        filtersAccordion.style.display = 'none';
        setupScrollListeners(femaleStyleOptionsGroup);
    }
    
    if (imageCaptured) resetSession();
}

function toggleFilterSection(section) {
    if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        section.classList.add('expanded');
    } else {
        section.classList.remove('expanded');
        section.classList.add('collapsed');
    }
}

function handleComplexionSelect(tile) {
    if (selectedGender !== 'Male') return;
    
    const isSelected = tile.classList.contains('selected');
    const complexionTiles = complexionGroup.querySelectorAll('.complexion-tile');
    const code = tile.dataset.complexionCode;

    complexionTiles.forEach(t => t.classList.remove('selected'));
    
    let newFilterCode = null;

    if (!isSelected) {
        tile.classList.add('selected');
        newFilterCode = code; 
    } 
    
    selectedComplexionCode = newFilterCode;
    updateMaleStyleGallery(selectedComplexionCode);
}

function handleStyleSelect(styleOption) {
    const scrollContainer = styleOption.closest('.hairstyle-options-group-wrapper');
    if (scrollContainer) {
        const containerWidth = scrollContainer.clientWidth;
        const optionWidth = styleOption.offsetWidth;
        const scrollTarget = styleOption.offsetLeft - (containerWidth / 2) + (optionWidth / 2);
        
        scrollContainer.scrollTo({
            left: scrollTarget,
            behavior: 'smooth'
        });
    }
}

async function startCamera() {
    if (cameraStarted) return; 
    statusMessage.textContent = "Requesting camera access...";
    cameraCaptureBtn.disabled = true;
    errorContainer.classList.remove('visible');

    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('Camera access not supported on this device/browser');
        }
        
        const constraints = {
            video: {
                facingMode: 'user', 
                width: { ideal: 640 },
                height: { ideal: 640 }
            }
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoFeed.srcObject = stream;
        
        await new Promise((resolve, reject) => {
            videoFeed.onloadedmetadata = () => {
                videoFeed.play()
                    .then(resolve)
                    .catch(reject);
            };
            setTimeout(() => reject(new Error('Camera initialization timeout')), 10000);
        });

        cameraStarted = true;
        imageCaptured = false;
        aiGenerationComplete = false;

        cameraPlaceholderIcon.style.display = 'none'; 
        aiResultImg.style.display = 'none';
        videoFeed.style.display = 'block'; 

        updateButtonVisibility();
    } catch (error) {
        console.error('Error accessing camera:', error);
        
        let errorMessage = 'Camera Error: ';
        
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            errorMessage += 'Camera permission denied. Please enable camera access in your browser settings.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage += 'No camera found on this device.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage += 'Camera is already in use by another application.';
        } else {
            errorMessage += error.message;
        }
        
        showError(errorMessage, 0);
        cameraPlaceholderIcon.style.display = 'block';
        videoFeed.style.display = 'none';
        cameraStarted = false;
        updateButtonVisibility(); 
    }
}

function stopCamera() {
    if (videoFeed.srcObject) {
        videoFeed.srcObject.getTracks().forEach(track => track.stop());
        videoFeed.srcObject = null;
    }
    cameraStarted = false;
}

function captureImage() {
    if (!cameraStarted) return;

    const context = canvas.getContext('2d');
    const width = videoFeed.videoWidth || 640; 
    const height = videoFeed.videoHeight || 640;

    canvas.width = width;
    canvas.height = height;
    context.drawImage(videoFeed, 0, 0, width, height); 

    const fullDataURL = canvas.toDataURL('image/jpeg');
    const parts = fullDataURL.split(',');
    capturedImageBase64 = parts.length > 1 ? parts[1] : fullDataURL;

    imageCaptured = true;
    aiGenerationComplete = false; 

    videoFeed.style.display = 'none';
    aiResultImg.style.display = 'block';
    aiResultImg.src = fullDataURL; 

    stopCamera();
    updateButtonVisibility();
}

function resetSession() {
    stopCamera();
    aiResultImg.style.display = 'none';
    cameraPlaceholderIcon.style.display = 'block';
    imageCaptured = false;
    aiGenerationComplete = false; 
    capturedImageBase64 = null;
    spinner.classList.remove('active');

    if(selectedGender === 'Male') {
        updateMaleStyleGallery(selectedComplexionCode);
    } else {
        setupScrollListeners(femaleStyleOptionsGroup);
    }

    filtersAccordion.classList.remove('expanded');
    filtersAccordion.classList.add('collapsed');

    updateButtonVisibility();
}

cameraCaptureBtn.addEventListener('click', captureImage);

cameraPlaceholderIcon.addEventListener('click', () => {
    if (!cameraStarted && !imageCaptured) {
        startCamera();
    }
});

redoSelfieBtn.addEventListener('click', () => {
    resetSession();
    startCamera(); 
});

generateLookBtn.addEventListener('click', async () => {
    if (!capturedImageBase64 || !selectedPrompt) {
        statusMessage.textContent = "Please capture a selfie and select a hairstyle first.";
        return;
    }

    errorContainer.classList.remove('visible');
    spinner.classList.add('active');
    updateButtonVisibility();
    statusMessage.textContent = "Uploading image and defining style...";

    const complexionClause = selectedComplexionCode
        ? ` with a ${selectedComplexionCode === 'ds' ? 'darkest' : 'standard'} complexion`
        : ``;

    const finalPrompt = `STRICTLY operate in an inpainting/editing mode. The ONLY element to be changed is the subject's hair. PRESERVE the subject's face, identity, expression, clothing, and background EXACTLY as they appear in the original photograph. Apply the following hairstyle, matching its texture, color, and shape: ${selectedPrompt}. The final result must be a high quality, professional studio portrait of a ${selectedGender} model${complexionClause} with NO other changes besides the hair.`;

    try {
        statusMessage.textContent = "Processing your new look (this may take 30-60 seconds)...";
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 90000);
        
        const response = await fetch('/.netlify/functions/run_model', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                baseImage: capturedImageBase64,
                prompt: finalPrompt,
                negativePrompt: NEGATIVE_PROMPT
            }),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.details || errorData.error || `Server error: ${response.status}`);
        }

        const data = await response.json();

        if (!data.generatedImageBase64) {
            throw new Error('No image data received from server');
        }

        aiResultImg.src = `data:image/jpeg;base64,${data.generatedImageBase64}`;
        aiResultImg.style.display = 'block';
        videoFeed.style.display = 'none';
        cameraPlaceholderIcon.style.display = 'none';

        aiGenerationComplete = true;
        imageCaptured = true;
        capturedImageBase64 = data.generatedImageBase64; 
        
        spinner.classList.remove('active');
        updateButtonVisibility();
        statusMessage.textContent = "âœ¨ Success! Your new look is ready.";

    } catch (error) {
        console.error('AI Processing Error:', error);
        
        let errorMessage = 'An error occurred during AI processing. ';
        
        if (error.name === 'AbortError') {
            errorMessage += 'Request timed out. Please try again.';
        } else if (error.message.includes('Failed to fetch')) {
            errorMessage += 'Network error. Check your internet connection.';
        } else if (error.message.includes('REPLICATE_API_TOKEN')) {
            errorMessage += 'API configuration error. Please contact support.';
        } else {
            errorMessage += error.message;
        }
        
        showError(errorMessage, 10000);
        spinner.classList.remove('active');
        updateButtonVisibility();
    }
});

bookAppointmentBtn.addEventListener('click', () => {
    if (!aiGenerationComplete) {
        statusMessage.textContent = "Please generate a look first before booking.";
        return;
    }

    referenceImagePreview.src = aiResultImg.src;
    selectedStyleNameSpan.textContent = selectedStyleLabel;
    bookingModalOverlay.classList.add('visible');
});

modalCloseBtn.addEventListener('click', () => {
    bookingModalOverlay.classList.remove('visible');
});

bookingForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const bookingStatusMessage = document.getElementById('booking-status-message');
    const submitButton = bookingForm.querySelector('.submit-btn');

    submitButton.textContent = "Processing...";
    submitButton.disabled = true;
    bookingStatusMessage.style.color = '#ffc107';
    bookingStatusMessage.textContent = "Connecting to scheduling service...";
    
    const name = document.getElementById('name').value;
    const email = document.getElementById('email').value;
    const date = document.getElementById('date').value;
    const time = document.getElementById('time').value;

    const bookingData = {
        firstName: name.split(' ')[0] || '',
        lastName: name.split(' ').slice(1).join(' ') || '',
        email: email,
        datetime: `${date}T${time}:00`,
        appointmentType: selectedGender === 'Male' ? 'Men\'s Cut' : 'Women\'s Cut', 
        styleName: selectedStyleLabel,
        stylePrompt: selectedPrompt,
        imageReference: aiResultImg.src, 
    };
    
    console.log("Booking data prepared:", bookingData);

    setTimeout(() => {
        bookingStatusMessage.style.color = 'var(--highlight-color)'; 
        bookingStatusMessage.textContent = "Booking Confirmed! Check your email for details.";
        submitButton.textContent = "Confirmed!";
    }, 2000); 
});

function initialize() {
    if (maleGenderBtn) {
        maleGenderBtn.addEventListener('click', () => handleGenderSelect('Male'));
    }

    if (femaleGenderBtn) {
        femaleGenderBtn.addEventListener('click', () => handleGenderSelect('Female'));
    }

    if (filtersAccordion) {
        filtersAccordion.querySelector('h3').addEventListener('click', () => toggleFilterSection(filtersAccordion));
        filtersAccordion.classList.add('collapsed');
    }

    if (complexionGroup) {
        complexionGroup.querySelectorAll('.complexion-tile').forEach(tile => {
            tile.addEventListener('click', () => handleComplexionSelect(tile));
        });
    }
    
    handleGenderSelect('Male');
}

initialize();
